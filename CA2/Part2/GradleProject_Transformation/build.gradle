plugins {
    id 'org.springframework.boot' version '3.3.2'
    id 'io.spring.dependency-management' version '1.1.5'
    id 'java'
}


repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-hateoas'
    runtimeOnly 'com.h2database:h2'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
}

bootJar {
    mainClass = 'payroll.PayrollApplication'
}


// 1) Clean the deployment directory
task cleanDeploy(type: Delete) {
    description = "Delete the dev deployment directory"
    delete "$buildDir/deployment/dev"
}

// 2) Copy the assembled application artifact (bootJar) into deployment dir
task copyArtifact(type: Copy) {
    description = "Copy the main application artifact (bootJar) to the deployment directory"
    dependsOn bootJar
    // bootJar.archiveFile is a Provider; use it inside a closure so it resolves at execution time
    from { bootJar.archiveFile } 
    into "$buildDir/deployment/dev"
}

// 3) Copy runtime JAR dependencies into deployment/lib
task copyRuntimeDeps(type: Copy) {
    description = "Copy runtime JAR dependencies into deployment/lib"
    // Ensure classes/deps are resolved
    dependsOn classes
    from {
        // only JAR files from the runtimeClasspath (excludes directories)
        configurations.runtimeClasspath.filter { it.name.endsWith('.jar') }
    }
    into "$buildDir/deployment/dev/lib"
}

// 4) Copy configuration files and inject tokens (version + timestamp)
task copyConfig(type: Copy) {
    description = "Copy properties files to deployment and replace tokens (version, buildTimestamp)"
    from('src/main/resources') {
        include '*.properties'
        // use the Ant ReplaceTokens filter inline (fully-qualified class name)
        filter(org.apache.tools.ant.filters.ReplaceTokens, 
               tokens: [
                   version: (project.hasProperty('version') ? project.version : 'unspecified'),
                   buildTimestamp: new Date().format("yyyy-MM-dd'T'HH:mm:ss")
               ])
    }
    into "$buildDir/deployment/dev"
}

// Main orchestrator task that ensures sequential execution
task deployToDev {
    description = "Prepare a dev deployment: clean -> artifact -> runtime libs -> configs (with token replacement)"
    // make this run the steps
    dependsOn cleanDeploy, copyArtifact, copyRuntimeDeps, copyConfig

    // enforce execution order
    copyArtifact.mustRunAfter cleanDeploy
    copyRuntimeDeps.mustRunAfter copyArtifact
    copyConfig.mustRunAfter copyRuntimeDeps

    doLast {
        println "Deployment prepared at: ${buildDir}/deployment/dev"
    }
}


// runServer Task
task runServer(type: JavaExec, dependsOn: classes) {
    group = "DevOps"
    description = "Launches a chat/server application (default port 59001)"
  
    classpath = sourceSets.main.runtimeClasspath
    mainClass = 'basic_demo.ChatServerApp' // Change if main class is different

    args '59001'
}

// Unit test configuration (enables JUnit 5 test output)
test {
    useJUnitPlatform()
    testLogging {
        events "passed", "skipped", "failed"
    }
}

// backup Task
task backup(type: Copy) {
    group = "DevOps"
    description = "Backs up source files to the backup directory"
  
    from 'src'
    into 'backup/src'
    include '**/*.java'
}

// zipBackup Task
tasks.register('zipBackup', Zip) {
    dependsOn tasks.named('backup')
    from 'backup/src'
    archiveFileName = "app-backup.zip"
    destinationDirectory = file("backup/zips")
}

// Custom task that depends on installDist
task runInstalledApp {
    group = "DevOps"
    description = "Runs the app using the distribution script generated by installDist"

    dependsOn installDist  //  makes it depend on installDist

    doLast {
        // Figure out correct script based on OS
        def scriptName = "GradleProject_Transformation" 
        def scriptExt = System.getProperty('os.name').toLowerCase().contains('win') ? '.bat' : ''
        def scriptPath = "$buildDir/install/${scriptName}/bin/${scriptName}${scriptExt}"

        println "Running installed app from: ${scriptPath}"

        // Run the generated script
        if (System.getProperty('os.name').toLowerCase().contains('win')) {
            exec {
                commandLine 'cmd', '/c', scriptPath
            }
        } else {
            exec {
                commandLine 'bash', scriptPath
            }
        }
    }
}

// javadocZip Task 
tasks.register('javadocZip', Zip) {
    dependsOn tasks.named('javadoc')
    group = 'DevOps'
    description = 'Generate javadoc and zip the documentation'

    from tasks.named('javadoc').map { it.destinationDir }
    archiveFileName = 'javadoc.zip'
    destinationDirectory = file("$buildDir/docs")
}

// Integration Test Source Set and Task
sourceSets {
    integrationTest {
        java {
            srcDir 'src/integrationTest/java'
        }
        resources {
            srcDir 'src/integrationTest/resources'
        }
    }
}

configurations {
    integrationTestImplementation.extendsFrom testImplementation
    integrationTestRuntimeOnly.extendsFrom testRuntimeOnly
}

task integrationTest(type: Test) {
    description = 'Runs integration tests.'
    group = 'verification'
    testClassesDirs = sourceSets.integrationTest.output.classesDirs
    classpath = sourceSets.integrationTest.runtimeClasspath
    shouldRunAfter test
    useJUnitPlatform()
}

// Make Gradle’s built-in “check” task run integration tests too
check.dependsOn integrationTest

// Java Toolchain (Java 17 use)
java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(17)
    }
}
